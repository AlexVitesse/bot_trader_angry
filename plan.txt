ROADMAP: BINANCE SCALPER & ML EVOLUTION
META FINAL: Bot de Trading de Alta Frecuencia (HFT) autonomo potenciado por ML.

[ESTADO ACTUAL]
Fase: FASE 2.5 - PERSISTENCIA DE DATOS (COMPLETADA) -> Siguiente: FASE 2.7
Proximo Hito: Implementar Telegram + Slippage test + Position sizing dinamico.
Bot corriendo en: Binance Futures Testnet
Ultima actualizacion: 2026-02-10

---

FASE -1: VALIDACION DE ESTRATEGIA (COMPLETADA)
[X] Backtest v1.0 - v5.0: Diversas pruebas de Mean Reversion.
[X] Backtest v6.7 (Smart Metralladora): +43.78% PnL, 83% WR, PF 1.48 (APROBADA)
    - Backtest corregido: usa high/low intra-vela, orden TP>SL>DCA, comisiones reales
    - Parametros unificados con settings.py ($12 margen, 10x leverage)

ESTRATEGIA ACTUAL (v6.7 - SMART METRALLADORA):
  - Tipo: Grinder de Alta Frecuencia (Trend Following Mean Reversion)
  - Par: BTC/USDT Futures | Timeframe: 1m
  - Entrada: Filtro EMA 200 + Bollinger Bands + StochRSI.
  - Gestion: DCA (Grinder) - Max 2 Safety Orders (Martingale x2).
  - Apalancamiento: 10x | Margen Base: $12 | TP: 0.6% | SL: 1.5%.
  - Modo: Agresivo (filtros ATR y Rolling WR disponibles pero desactivados).

AUDITORIA DE CODIGO (2026-02-10):
[X] Fix validate_config() - referencia a variable eliminada (ATR_SL_MULTIPLIER)
[X] Fix evaluacion TP/DCA/SL - SL ahora se evalua ANTES de DCA
[X] Fix loop principal - ya no llama update_position con high=low=price
[X] Verificacion de balance antes de ejecutar DCA
[X] Reconexion WS con backoff exponencial (5s-5min, max 10 intentos)
[X] Eliminacion de estado duplicado Strategy/Trader
[X] Tests corregidos (test_bot.py, strategy __main__)
[X] Protecciones implementadas (Rolling WR + ATR regime filter) - desactivadas modo agresivo

---

FASE 0: CIMIENTOS DE INGENIERIA (COMPLETADA)
[X] Entorno Python (Poetry) + Librerias (pandas_ta, websocket-client, requests).
[X] Repositorio Git inicializado.

FASE 1: LA TUBERIA DE DATOS (COMPLETADA)
[X] Conexion a Binance via Websocket (Tiempo Real).
[X] Descargador de historial masivo (fetch_history.py).

FASE 2: EL MOTOR DE TRADING v1.0 (COMPLETADA)
[X] Modulo de Ejecucion con soporte para DCA/Safety Orders.
[X] Paper Trading activo en Testnet.
[X] Backtest corregido y validado con parametros reales.
[X] Kill switches: 3 consecutive losses, 20% daily loss.

FASE 2.5: PERSISTENCIA DE DATOS (COMPLETADA)
[X] SQLite: Tabla trades (entry/exit price, side, pnl, dca_count, duration, exit_reason)
[X] SQLite: Tabla features (snapshot de indicadores al momento de cada entrada)
    - EMA 200 dist%, BB position%, StochRSI K/D, ATR, ATR ratio, volumen
    - Contexto: hora_utc, dia_semana, spread, volatilidad_reciente
[X] SQLite: Tabla candles (OHLCV 1m para re-entrenar modelo sin depender de Parquet)
[X] SQLite: Tabla active_position (estado de posicion abierta para recovery tras reinicio)
[X] Modulo src/database.py: CRUD + queries de entrenamiento (get_training_data())
[X] Logging real a archivo (bot.log) - setup_logging() en bot.py
[X] Feature capture automatico: guardar indicadores en cada open_position()
[X] Migracion: trade_history se carga desde SQLite al iniciar (_load_trade_history)
[X] Recovery de posicion: sync_with_exchange() prioriza DB sobre exchange
[X] Test: CRUD verificado (insert, read, update, delete en todas las tablas)

FASE 2.7: ROBUSTEZ OPERATIVA (Pre-requisito Live)
  Objetivo: Asegurar que el bot sobrevive en produccion 24/7 sin supervision.

  Slippage & Validacion del Edge
  [ ] Agregar SLIPPAGE_PCT a settings.py (0.01-0.02% estimado para BTC)
  [ ] Re-correr backtest con slippage incluido en TP/SL fills
  [ ] Si PF < 1.2 con slippage, ajustar TP (subir a 0.7-0.8%)
  [ ] Documentar impacto real del slippage en resultados

  Position Sizing Dinamico
  [ ] Cambiar BASE_ORDER_MARGIN fijo ($12) -> % del balance actual
  [ ] Parametro en settings.py: POSITION_SIZE_PCT = 0.12 (12% del balance)
  [ ] Margen = balance * POSITION_SIZE_PCT (crece con ganancias, se reduce con perdidas)
  [ ] Minimo: $12 (para cumplir minimo de Binance de $100 notional con 10x)
  [ ] Actualizar backtest para simular position sizing dinamico

  Alertas de Telegram (Monitoreo Remoto)
  [ ] Bot de Telegram: crear con BotFather, guardar token en .env
  [ ] Modulo src/telegram_alerts.py: enviar mensajes async (no bloquear trading)
  [ ] Alertas en: apertura/cierre de trade, DCA ejecutado, kill switch activado
  [ ] Alerta en: desconexion de WebSocket, error critico
  [ ] Resumen diario automatico: trades, WR, PnL, balance actual
  [ ] Comando /status para consultar estado del bot desde Telegram

FASE 3: VALIDACION LIVE LOCAL (Primer contacto con dinero real)
  Pre-requisitos: Fase 2.5 + 2.7 completadas, 48h+ estable en testnet.
  Objetivo: Confirmar que la estrategia es rentable en real ANTES de invertir en infra.
  Ejecutar desde PC local (aceptar riesgo de desconexion temporal).

  [ ] Validar estabilidad del Websocket 48h+ continuas en testnet
  [ ] Verificar sync_with_exchange() funciona correctamente tras reinicio
  [ ] Despliegue con capital real MINIMO: $100 USDT
  [ ] Monitoreo primera semana: revisar logs + Telegram diariamente
  [ ] Evaluar resultados reales vs backtest despues de 2-4 semanas (~100+ trades)
  [ ] Decision: si es rentable -> Fase 3.5 (VPS). Si no -> ajustar estrategia.

  PROYECCION DE RENTABILIDAD (referencia, NO garantia):
  Capital minimo viable: $100 (margen $12 + colchon para DCA)
  Con $10: NO VIABLE (margen minimo $12 para cumplir $100 notional en Binance)
  Con $100 margen fijo $12: ~$17-43/mes (pesimista-optimista)
  Con $200 margen fijo $12: mismo PnL absoluto, pero mas colchon de seguridad
  Con $200 + sizing dinamico (12%): ~$34-86/mes (escala con balance)
  NOTA: Backtest es optimista. Esperar 30-50% menos en live por slippage y latencia.

FASE 3.5: MIGRACION A VPS (Solo si Fase 3 es rentable)
  Objetivo: Operar 24/7 sin depender del PC local.
  Decision basada en: resultados reales de Fase 3 (minimo 2 semanas de datos).

  [ ] Contratar VPS (opciones por costo):
      - Oracle Cloud Free Tier: $0/mes (ARM 4 cores, 24GB RAM, 10TB transfer) - RECOMENDADO
      - AWS Lightsail: $3.50/mes (1 core, 512MB RAM, 1TB transfer)
      - Hetzner CX22: $4.50/mes (2 cores, 4GB RAM, 20TB transfer)
      - Contabo VPS S: $5.50/mes (4 cores, 8GB RAM, ilimitado)
      NOTA: Bot usa <5 GB/mes de datos, cualquier plan sobra.
  [ ] Setup: Ubuntu 22.04+ | Python 3.12 | Poetry | Git clone del repo
  [ ] Configurar bot como servicio systemd (auto-reinicio si crashea)
  [ ] Configurar logrotate para bot.log (evitar que llene disco)
  [ ] Firewall: solo SSH + outbound HTTPS (Binance API + Telegram)
  [ ] Backup automatico de SQLite (cron diario -> cloud storage o local)
  [ ] Validar estabilidad 48h+ en VPS antes de mover capital completo

FASE 4A: ML PREDICTOR - FILTRO DE ENTRADAS (Modelo Propio)
  Objetivo: Reducir falsas entradas prediciendo P(win) antes de abrir posicion.
  Modelo: XGBoost o LightGBM (tabular, <1ms prediccion, $0 costo, local).
  Requisito: Minimo ~500 trades etiquetados (WIN/LOSS) con features.

  PASO 1 - Recoleccion de datos (~2-4 semanas de bot corriendo)
  [ ] Acumular trades con features en SQLite (automatico desde Fase 2.5)
  [ ] Monitorear calidad de datos: sin NaN, features consistentes
  [ ] Meta: 500+ trades etiquetados con features completos

  PASO 2 - Feature Engineering (src/ml/features.py)
  [ ] Extraer features del DataFrame al momento de senal:
      - Distancia precio vs EMA 200 (%)
      - Posicion dentro de Bollinger Bands (0-1)
      - StochRSI K y D
      - ATR / ATR_SMA ratio (regimen de volatilidad)
      - Volumen relativo (vol / vol_sma_20)
      - Spread (high-low) relativo
      - Hora UTC, dia de la semana (ciclico: sin/cos encoding)
      - Retorno ultimas 5, 15, 60 velas
      - Racha actual (wins/losses consecutivas)
  [ ] Analisis de correlacion: descartar features redundantes
  [ ] Normalizacion / scaling donde sea necesario

  PASO 3 - Entrenamiento del Modelo (src/ml/trainer.py)
  [ ] Split temporal: 70% train / 15% validation / 15% test (NO random, SIEMPRE cronologico)
  [ ] Entrenar XGBoost clasificador binario (WIN=1, LOSS=0)
  [ ] Optimizar hiperparametros con Optuna o grid search
  [ ] Metricas clave: Precision, Recall, F1, AUC-ROC
  [ ] Validar que no hay overfitting: test performance ~= validation
  [ ] Guardar modelo entrenado (joblib/pickle) en models/

  PASO 4 - Backtest con ML Filter (src/ml/backtest_ml.py)
  [ ] Re-correr backtest historico PERO filtrando entradas con P(win) < threshold
  [ ] Encontrar threshold optimo: maximizar PnL manteniendo suficientes trades
  [ ] Comparar metricas: WR, PF, Max DD, Sharpe con vs sin ML filter
  [ ] El filtro debe mejorar PF sin reducir trades mas de 30-40%

  PASO 5 - Integracion en Bot Live (src/ml/predictor.py)
  [ ] Modulo predictor: carga modelo, recibe features, retorna P(win)
  [ ] Integrar en bot.py: antes de open_position(), consultar predictor
  [ ] Si P(win) < threshold -> skip entrada (log motivo)
  [ ] Threshold configurable en settings.py (ML_CONFIDENCE_THRESHOLD)
  [ ] Fallback: si modelo falla, operar sin filtro (log warning)

  PASO 6 - Reentrenamiento Continuo
  [ ] Script de reentrenamiento semanal/mensual con datos nuevos
  [ ] Comparar modelo nuevo vs anterior (champion/challenger)
  [ ] Solo reemplazar si modelo nuevo es mejor en metricas clave
  [ ] Alertar si performance del modelo degrada significativamente

FASE 4B: ANALISTA LLM - MACRO FILTER (Opcional, Largo Plazo)
  Objetivo: Pausar bot automaticamente en eventos macro (FOMC, hacks, crash).
  Modelo: API de Claude/GPT para analisis de texto (no para trades individuales).
  Frecuencia: Cada 1-4 horas (NO por trade - seria lento y caro).

  [ ] Conectar API de noticias crypto (CryptoPanic, CoinGecko news, Twitter/X)
  [ ] Enviar resumen a LLM: "Hay algun evento que haga peligroso operar BTC ahora?"
  [ ] LLM responde: SAFE / CAUTION / DANGER con razon
  [ ] Si DANGER -> pausar bot hasta proximo chequeo
  [ ] Logging de decisiones del LLM para auditar despues

FASE 5: OPTIMIZACION Y ESCALADO (Largo Plazo)
[ ] Multi-par: expandir a ETH/USDT, SOL/USDT con misma estrategia.
[ ] Migracion a VPS mas potente si latencia es problema.
[ ] Reescribir modulos criticos en Rust o C++ si Python es lento.
[ ] Arbitraje entre Exchanges (anadir segundo Exchange).
